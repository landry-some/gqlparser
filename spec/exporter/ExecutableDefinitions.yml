schema:
  - |
    schema {
      query: QueryRoot
    }

    directive @onQuery on QUERY

    directive @onMutation on MUTATION

    directive @onSubscription on SUBSCRIPTION

    directive @onField on FIELD

    directive @onFragmentDefinition on FRAGMENT_DEFINITION

    directive @onFragmentSpread on FRAGMENT_SPREAD

    directive @onInlineFragment on INLINE_FRAGMENT

    directive @onSchema on SCHEMA

    directive @onScalar on SCALAR

    directive @onObject on OBJECT

    directive @onFieldDefinition on FIELD_DEFINITION

    directive @onArgumentDefinition on ARGUMENT_DEFINITION

    directive @onInterface on INTERFACE

    directive @onUnion on UNION

    directive @onEnum on ENUM

    directive @onEnumValue on ENUM_VALUE

    directive @onInputObject on INPUT_OBJECT

    directive @onInputFieldDefinition on INPUT_FIELD_DEFINITION

    type Alien implements Being & Intelligent {
      iq: Int
      name(surname: Boolean): String
      numEyes: Int
    }

    scalar Any

    interface Being {
      name(surname: Boolean): String
    }

    interface Canine {
      name(surname: Boolean): String
    }

    type Cat implements Being & Pet {
      name(surname: Boolean): String
      nickname: String
      meows: Boolean
      meowVolume: Int
      furColor: FurColor
    }

    union CatOrDog = Dog | Cat

    input ComplexInput {
      requiredField: Boolean!
      nonNullField: Boolean! = false
      intField: Int
      stringField: String
      booleanField: Boolean
      stringListField: [String]
    }

    type ComplicatedArgs {
      intArgField(intArg: Int): String
      nonNullIntArgField(nonNullIntArg: Int!): String
      stringArgField(stringArg: String): String
      booleanArgField(booleanArg: Boolean): String
      enumArgField(enumArg: FurColor): String
      floatArgField(floatArg: Float): String
      idArgField(idArg: ID): String
      stringListArgField(stringListArg: [String]): String
      stringListNonNullArgField(stringListNonNullArg: [String!]): String
      complexArgField(complexArg: ComplexInput): String
      multipleReqs(req1: Int!, req2: Int!): String
      nonNullFieldWithDefault(arg: Int! = 0): String
      multipleOpts(opt1: Int = 0, opt2: Int = 0): String
      multipleOptAndReq(req1: Int!, req2: Int!, opt1: Int = 0, opt2: Int = 0): String
    }

    type Dog implements Being & Pet & Canine {
      name(surname: Boolean): String
      nickname: String
      barkVolume: Int
      barks: Boolean
      doesKnowCommand(dogCommand: DogCommand): Boolean
      isHousetrained(atOtherHomes: Boolean = true): Boolean
      isAtLocation(x: Int, y: Int): Boolean
    }

    enum DogCommand {
      SIT
      HEEL
      DOWN
    }

    union DogOrHuman = Dog | Human

    enum FurColor {
      BROWN
      BLACK
      TAN
      SPOTTED
      NO_FUR
      UNKNOWN
    }

    type Human implements Being & Intelligent {
      name(surname: Boolean): String
      pets: [Pet]
      relatives: [Human]
      iq: Int
    }

    union HumanOrAlien = Human | Alien

    interface Intelligent {
      iq: Int
    }

    scalar Invalid

    interface Pet {
      name(surname: Boolean): String
    }

    type QueryRoot {
      human(id: ID): Human
      alien: Alien
      dog: Dog
      cat: Cat
      pet: Pet
      catOrDog: CatOrDog
      dogOrHuman: DogOrHuman
      humanOrAlien: HumanOrAlien
      complicatedArgs: ComplicatedArgs
      invalidArg(arg: Invalid): String
      anyArg(arg: Any): String
    }
tests:
  - names: []
    rule: ExecutableDefinitions
    schema: 0
    query: |2-
            
            query Foo {
              dog {
                name
              }
            }
            
    errors: []
  - names: []
    rule: ExecutableDefinitions
    schema: 0
    query: |2-
            
            query Foo {
              dog {
                name
                ...Frag
              }
            }
            
            fragment Frag on Dog {
              name
            }
            
    errors: []
  - name: 'Validate: Executable definitions/with type definition'
    rule: ExecutableDefinitions
    schema: 0
    query: |2-
            
            query Foo {
              dog {
                name
              }
            }
            
            type Cow {
              name: String
            }
            
            extend type Dog {
              color: String
            }
            
    errors:
      - message: The Cow definition is not executable.
        locations: [{line: 8, column: 7}]
      - message: The Dog definition is not executable.
        locations: [{line: 12, column: 7}]
  - name: 'Validate: Executable definitions/with schema definition'
    rule: ExecutableDefinitions
    schema: 0
    query: |2-
            
            schema {
              query: Query
            }
            
            type Query {
              test: String
            }
            
            extend schema @directive
            
    errors:
      - message: The schema definition is not executable.
        locations: [{line: 2, column: 7}]
      - message: The Query definition is not executable.
        locations: [{line: 6, column: 7}]
      - message: The schema definition is not executable.
        locations: [{line: 10, column: 7}]
